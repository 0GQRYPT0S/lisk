/*
 * Copyright Â© 2018 Lisk Foundation
 *
 * See the LICENSE file at the top-level directory of this distribution
 * for licensing information.
 *
 * Unless otherwise agreed in a custom licensing agreement with the Lisk Foundation,
 * no part of this software, including this file, may be copied, modified,
 * propagated, or distributed except according to the terms contained in the
 * LICENSE file.
 *
 * Removal or modification of this copyright notice is prohibited.
 */
'use strict';

const Promise = require('bluebird');

/**
 * @class PGPromiseStub
 */
class PGPromiseStub {
	/**
	 * @constructor
	 * @param {external:Database} db
	 * Database object from pg-promise, to be automatically stubbed.
	 */
	constructor(db) {
		this.db = db;
	}

	/**
	 * @method PGPromiseStub#intercept
	 * @description
	 * Helps testing SQL generated by a database method, it executes the method, while intercepting the SQL execution.
	 * If the method executes SQL at multiple points, it will be interrupted at the first point.
	 *
	 * @param {string|Function} method
	 * Database method to be invoked. It can be either the full name available from the Database object,
	 * or the actual method - function reference.
	 *
	 * @param params
	 * Value-formatting parameters to be passed into the database method.
	 *
	 * @returns {Promise<string>}
	 * Resolves with the query - SQL string that the method attempted to execute.
	 */
	intercept(method, params) {
		if (typeof method !== 'function') {
			if (!method || typeof method !== 'string') {
				return Promise.reject(
					new TypeError(`Invalid parameter method: ${JSON.stringify(method)}`)
				);
			}
			if (!(method in this.db)) {
				return Promise.reject(
					new TypeError(`Invalid method name: ${JSON.stringify(method)}`)
				);
			}
		}
		const methodName = typeof method === 'string' ? `${method} ` : '';
		return new Promise((resolve, reject) => {
			const opt = this.db.$config.options;
			const oldQuery = opt.query;
			let sql;
			opt.query = e => {
				sql = e.query;
				throw null;
			};
			method(...params)
				.then(data => {
					throw new Error(
						`Method ${methodName}resolved without trying to execute any query, with data: ${JSON.stringify(
							data
						)}`
					);
				})
				.catch(error => {
					if (error === null) {
						resolve(sql);
					} else {
						reject(error);
					}
				})
				.finally(() => {
					opt.query = oldQuery;
				});
		});
	}

	/**
	 * @method PGPromiseStub#execute
	 * @description
	 * Helps testing SQL generated by a database method, side-by-side with the data resolved by the method.
	 * If the method executes SQL at multiple points, only the first attempt will be captured.
	 *
	 * @param {string|Function} method
	 * Database method to be invoked. It can be either the full name available from the Database object,
	 * or the actual method - function reference.
	 *
	 * @param params
	 * Value-formatting parameters to be passed into the database method.
	 *
	 * @returns {Promise<{sql, data}>}
	 *  - Resolves with `{sql, data}` - SQL + resolved data
	 */
	execute(method, params) {
		if (typeof method !== 'function') {
			if (!method || typeof method !== 'string') {
				return Promise.reject(
					new TypeError(`Invalid parameter method: ${JSON.stringify(method)}`)
				);
			}
			if (!(method in this.db)) {
				return Promise.reject(
					new TypeError(`Invalid method name: ${JSON.stringify(method)}`)
				);
			}
		}
		const methodName = typeof method === 'string' ? `${method} ` : '';
		const opt = this.db.$config.options;
		const oldQuery = opt.query;
		let sql;
		opt.query = e => {
			sql = e.query;
		};
		return method(...params)
			.then(data => {
				if (sql) {
					return { sql, data };
				}
				throw new Error(
					`Method ${methodName}resolved without trying to execute any query, with data: ${JSON.stringify(
						data
					)}`
				);
			})
			.finally(() => {
				opt.query = oldQuery;
			});
	}
}

module.exports = PGPromiseStub;

/**
 * @external Database
 * @see http://vitaly-t.github.io/pg-promise/Database.html
 */
